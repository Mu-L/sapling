// @generated SignedSource<<e904b8d62470e9bb96e8bf4732ee81ea>>
// DO NOT EDIT THIS FILE MANUALLY!
// This file is a mechanical copy of the version in the configerator repo. To
// modify it, edit the copy in the configerator repo instead and copy it over by
// running the following in your fbcode directory:
//
// configerator-thrift-updater scm/hg/hgclientconf/hgclient.thrift
namespace py3 configerator

include "thrift/annotation/cpp.thrift"
include "thrift/annotation/rust.thrift"

struct TimeShard {
  1: string start;
  2: string end;
}

struct QE {
  1: string universe_name;
  2: string bool_param_name;
}

// Represents an access control list that can be used to gate access to a resource.
struct ACL {
  // This is the ACL type (e.g., USER, REPO, AUTH_SET, etc).
  1: string acl_type;
  // This is typically the name of the ACL in Hipster. It is referred to as "identity" in the ACL Checker Thrift API.
  2: string acl_identity;
  // The action you want to check if the authenticated user is permitted to perform (e.g., READ, WRITE, MEMBERS, etc).
  3: string acl_action;
  // If true, ACL will evaluate to true if the ACL Checker Service is unavailable or returns an error
  4: bool fail_open = false;
}

// Represents a boolean condition that evaluates to true or false.
// Condition composition can be done via the not, and, and or values.
// The possible condition values largely conform with the values available in
// Mercurial configparser crate. Case does not matter.
union Condition {
  // True if the inner condition is False
  @rust.Box
  @cpp.Ref{type = cpp.RefType.Unique}
  1: Condition not_condition;
  // True if all the inner conditions are True
  2: list<Condition> and_condition;
  // True if any of the inner conditions is True
  3: list<Condition> or_condition;
  // True if the current repo is one of the listed repos.
  // Ex: ["fbsource", "www"]
  4: list<string> repos;
  // True if the current platform is one of the listed platforms.
  // Ex: ["osx", "windows", "centos", "fedora", "ubuntu"]
  5: list<string> platforms;
  // True if the current domain is one of the listed domains
  // Ex: ["corp", "prod"]
  6: list<string> domains;
  // True if the current host is in one of the listed smc tiers
  // Ex: ["sys.devservers"]
  7: list<string> tiers;
  // True if the current host is one of the listed hosts
  // Ex: ["foo.facebook.com"]
  8: list<string> hosts;
  // True if the current host is in the given release phase
  // Ex: "dev", "alpha", "beta", or "stable"
  9: string group;
  // True if the current host is in the given shard
  // Ex: "1", "5", "45", "90", or "100"
  10: i32 shard;
  // True if the current user is in the given user shard. User shard is based
  // off their Mercurial ui.username value.
  // Ex: "1", "5", "45", "90", or "100"
  11: i32 user_shard;
  // True if the current time is within the given time shard. It contains a
  // start and end date, and more clients return True for this as it gets
  // closer to the end date. Standard Mercurial date strings are allowed.
  // Ex: ("June 9, 2020", "June 21, 2020")
  12: TimeShard time_shard;
  // True if the current host has one of the listed host prefixes
  // Ex: ["devvm"]
  13: list<string> host_prefixes;
  // For the given QE universe(s), checks the value of the specified boolean
  // param for the current Cross Environment Session ID, and returns True if any of them are True
  // More details:
  // QE is an additional filer used in combination with other filters.
  // In order to evaluate this filter on a particular host, we would send an additional request to:
  // https://interngraph.intern.facebook.com/testinfra/qe2 endpoint (interngraph.internmc.facebook.com for pub),
  // providing the "universe" name and host's Cross Environment Session ID.
  // In the response we would expect a set of params and its values.
  // For now we would only check the value of the param with the name specified in the QE here (must be boolean),
  // and the filter would only pass if the param's value is true.
  14: list<QE> qes;
  // YYYYMMDD like 20240411. Minimal version (inclusive) to apply the config.
  // To select the maximum version, use `not_condition`.
  15: i64 min_version_date;
  // Repo requirement to apply the config.
  // Either a store requirement or a working copy requirement.
  16: string repo_requirement;
  // True if the current authenticated user passes all listed ACLs.
  17: list<ACL> acls;
}

struct Hotfix {
  1: string config;
  2: Condition condition;
}

// The various configs that should be applied on Mercurial clients. There are
// likely to be three types of configs in the long run: hotfixes, features, and
// raw lua. The order of prededence between them will be such that the most
// flexible configuration can overwrite the least flexible. So the order they
// are applied in will be:
// 1. features
// 2. hotfixes
// 3. lua
struct ClientConfig {
  // Hotfixes are ordered and configs are applied in order.
  1: list<Hotfix> hotfixes;
  // Features will be supported later.
  // A feature is single condition that enables or disables a particular
  // feature in Mercurial. The actual configs for that feature are in the
  // client itself, and the feature flag only controls enabling or disabling
  // the feature, and will likely be controlled via automation.
  // Roughly equivalent to a Gatekeeper.
  // Ex: 2: map<string, Condition> features,

  // The features/hotfixes fields facilitate well structured configs and
  // easy changes via automation. In the future we may want to supplement or
  // replace it with more powerful raw lua configuration abilities.
  // Ex: 3: string lua_config,
}
